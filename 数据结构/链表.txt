单链表：data、next
双链表：pre、data、next（LinkedList）
循环链表
双向循环链表
提出问题：
    如何用链表来实现LRU缓存淘汰策略？（利用散列表优化）
        利用一个有序单链表，链表尾部是越早访问的，新数据插入到链表头部，
        数据在缓存链表中
            删除原来的，重新插入到头部
        不在缓存链表中
            链表满了
                删除尾部节点，插入新节点
            链表未满
                直接插入新节点
    什么是链表？
        通过指针将一组零散的内存块串联在一起的数据结构。
    几个概念：
        头结点：记录链表的基地址
        尾节点：指向NULL（循环链表指向头结点）
    什么是约瑟夫问题？
    对比分析一下双链表和单链表的？
        删除操作
            a、删除结点中“值等于某个给定值”的结点；
            b、删除给定指针指向的结点。
        在a这种情况下不管是单链表还是双链表，都需要先找到给定值的节点，将其删除，复杂度是一样的
        在b这种情况下双链表就可以直接获取前驱节点，进行删除操作了
        插入操作
            在某个指定的节点前面插入一个节点
        双链表也可以直接进行插入操作，而单链表需要先查找到next为指定节点的节点
    有何优势？
        天然支持动态扩容
    利用单链表实现判断回文字符串的问题？
    利用数组实现LRU缓存淘汰策略？ok
    单链表反转
    链表中环的检测
    两个有序的链表合并
    删除链表中倒数第N个节点
    求链表的中间节点
