单链表：data、next
双链表：pre、data、next（LinkedList）
循环链表
双向循环链表
提出问题：
    如何用链表来实现LRU缓存淘汰策略？（利用散列表优化）
        利用一个有序单链表，链表尾部是越早访问的，新数据插入到链表头部，
        数据在缓存链表中
            删除原来的，重新插入到头部
        不在缓存链表中
            链表满了
                删除尾部节点，插入新节点
            链表未满
                直接插入新节点
    什么是链表？
        通过指针将一组零散的内存块串联在一起的数据结构。
    几个概念：
        头结点：记录链表的基地址
        尾节点：指向NULL（循环链表指向头结点）
    什么是约瑟夫问题？
    对比分析一下双链表和单链表的？
        删除操作
            a、删除结点中“值等于某个给定值”的结点；
            b、删除给定指针指向的结点。
        在a这种情况下不管是单链表还是双链表，都需要先找到给定值的节点，将其删除，复杂度是一样的
        在b这种情况下双链表就可以直接获取前驱节点，进行删除操作了
        插入操作
            在某个指定的节点前面插入一个节点
        双链表也可以直接进行插入操作，而单链表需要先查找到next为指定节点的节点
    有何优势？
        天然支持动态扩容
    利用单链表实现判断回文字符串的问题？
    利用数组实现LRU缓存淘汰策略？ok
    单链表反转:这里用到递归思想。先判断是否有一个链表是空链表，是则返回两一个链表，免得指针指向不知名区域引发程序崩溃。
        然后每次比较两个链表的头结点，小的值做新链表的头结点，此节点的next指针指向本函数（递归开始，参数是较小值所在链表.next和另一个链表）
    链表中环的检测:创建两个指针一个快指针一次走两步一个慢指针一次走一步，若相遇则有环，若先指向nullptr则无环。
    两个有序的链表合并:这里用到递归思想。先判断是否有一个链表是空链表，是则返回两一个链表，免得指针指向不知名区域引发程序崩溃。
        然后每次比较两个链表的头结点，小的值做新链表的头结点，此节点的next指针指向本函数（递归开始，参数是较小值所在链表.next和另一个链表）
    删除链表中倒数第N个节点:创建两个指针，第一个先走k-1步然后两个在一同走。第一个走到最后时则第二个指针指向倒数第k位置。
    求链表的中间节点
