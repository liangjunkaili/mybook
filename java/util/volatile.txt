1、volatile关键字是与Java的内存模型有关的
	CPU、主存、高速缓存
	缓存一致性问题、共享变量
2、解决缓存不一致性问题（硬件层面上提供的方式）
	1）通过在总线加LOCK#锁的方式
　　2）通过缓存一致性协议（核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。）
原子性、可见性、有序性（指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。考虑指令之间的数据依赖性）
指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
3、要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
4、Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
5、Java提供了volatile关键字来保证可见性，一定的“有序性”。
6、happens-before原则（先行发生原则）：
    程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
    锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
    volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
    传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
    线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
    线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
    对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
7、volatile的含义
	1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。
8、atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。
9、synchronized、Lock、AtomicInteger