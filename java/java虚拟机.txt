二进制（第一位是符号位，0表示正数，1表示负数）
原码、反码（符号位不变，其余位取反）、补码（负数是反码加1，正数是原码本身）
1、使用补码作为整数编码，可以解决数字0的存储问题，可以简化整数的加减法计算，将减法计算视为加法计算，
实现减法和加法的完全统一，实现正数和负数加法的统一。
2、JVM的基本结构
	类加载子系统：负责从文件系统或网络中加载Class信息
	方法区：类信息、运行时常量池信息
	Java堆：虚拟机启动时建立，几乎所有的Java对象实例，所有线程共享的
	直接内存：NIO库使用，访问速度快于Java堆，大小受限于系统内存
	垃圾回收系统：可以对方法区、Java堆、直接内存进行回收，Java堆是垃圾收集器的工作重点
	Java栈：在线程创建时被创建，保存着帧信息、局部变量、方法参数，和java方法的调用、返回密切相关
	本地方法栈：用于本地方法调用
	PC寄存器：每一个java线程私有的空间，当前方法不是本地方法，指向当前正在被执行的指令
	执行引擎：负责执行虚拟机的字节码（当代虚拟机的即时编译技术）
3、虚拟机参数、应用程序参数
4、详解Java堆
	垃圾回收机制
	垃圾对象：存在于内存中、不会再被使用的对象。
	新生代回收
	新生代
		Eden区
		s0区（from）
		s1区（to）
	老年代
5、详解Java栈
	一块线程私有的内存空间
	线程执行的基本行为是函数调用
	函数调用对应栈帧（生成）入栈，函数调用结束对应栈帧（销毁）出栈
	栈帧包含局部变量表、操作数栈、帧数据区
	局部变量表：保存函数的参数、局部变量（jclasslib工具）
		字（word）：计算机内存中占据一个单独的内存单元编号的一组二进制串。64位计算机一个字为8个字节
		槽位：可复用
	操作数栈：保存计算过程的中间结果和变量临时的存储空间
	帧数据区：保存访问常量池的指针、异常处理表
	栈上分配：对于那些线程私有的对象，可以将它们打散分配在栈上，而不是分配在堆上。
		好处：是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能。
	逃逸分析：目的是判断对象的作用域是否有可能逃逸出函数体。
（注意：栈上分配依赖逃逸分析和标量替换的实现，由于栈空间较小，对于大对象无法在栈上分配）
6、详解方法区（永久区）---在1.8中被彻底移除
	一块所有线程共享的内存区域，大小决定了系统可以保存多少个类。
	注意：如果系统使用了动态代理，运行时可能会生成大量的类，导致永久区内存溢出。
7、元数据区（JDK1.8）
	这是一块堆外的直接内存
8、Java虚拟机参数
	跟踪垃圾回收：
		-XX:+PrintGC（简单信息）
		-XX:+PrintGCDetails（详细信息）
		-XX:+PrintHeapGC（全面的堆信息）
		-XX:+PrintGCTimeStamps(GC发生的时间)
		-XX:+PrintGCApplicationConcurrentTime（打印应用程序的执行时间）
		-XX:+PrintGCApplicationStoppedTime(打印应用程序由于GC产生的停顿时间)
		-XX:+PrintReferenceGC(软引用、弱引用、虚引用、Finallize队列)
		-Xloggc:log/gc.log（虚拟机允许将GC日志以文件的形式输出）
		-XX:+UseSerialGC（使用串行垃圾回收器）
	跟踪类加载/卸载：
		-verbose:class（类的加载和卸载）
		-XX:+TraceClassLoading（类的加载）
		-XX:+TraceClassUnloading(类的卸载)
		-XX:+PrintClassHistogram(运行时打印、查看系统中类的分布情况)
	系统参数查看：
		-XX:+PrintVMOptions(打印虚拟机接受到的命令行显式参数)
		-XX:+PrintCommandLineFlags(打印传递给虚拟机的显式和隐式参数)
		-XX:+PrintFlagsFinal(打印所有的系统参数的值)
	堆的配置参数：（最大可用内存小于最大内存原因是：由于垃圾回收的需要，虚拟机会对堆空间进行分区管理
	，不同区域采用不同的回收算法，一些算法会使用空间换时间的策略工作，会存在可用内存的损失）
		-Xms(初始堆空间)
		-Xmx(最大堆空间)
		-Xmn(设置新生代的大小，1/3到1/4)
		-XX:SurvivorRatio(设置新生代eden/from)
		-XX:NewRatio(老年代/新生代)
		-XX:+HeapDumpOnOutOfMemoryError(在内存溢出时导出整个堆信息)
		-XX:HeapDumpPath(指定导出堆的存放路径)（MAT工具）
		-XX:OnOutOfMemoryError(发送错误时执行一个脚本文件)
	方法区配置：
		JDK1.6-1.7：-XX:PermSize(初始的永久区大小)
					-XX:MaxPermSize(最大永久区)
		JDK1.8：-XX:MaxMetaspaceSize(永久区的最大可用值)
	栈配置：
		-Xss(指定线程的栈大小)
	直接内存配置：
		-XX:MaxDirectMemorySize(设置最大可用直接内存，默认值=-Xmx)
9、虚拟机的工作模式（-version）
	client
	server
10、垃圾回收算法：
	引用计数法：引用计数器（无法处理循环引用的情况，性能问题）-----未被java虚拟机采用
	标记清除法：（最大问题是：空间碎片）
		标记阶段
		清除阶段
	复制算法：（系统内存折半）---新生代串行垃圾回收器使用
	标记压缩法：---老年代的回收算法
		标记---压缩---清除
	分代算法：按照对象的生命周期长短分成两个部分
		卡表：
	分区算法：将整个堆空间划分成连续的不同小区间
11、垃圾回收的基本思想是考察每一个对象的可触及性（3种状态）
	可触及的
	可复活的（在finalize()函数中复活自己）
	不可触及的（可以被回收）
12、引用强度
	强引用：任何时候不会被回收
	在java.lang.ref
	软引用（引用队列，构造时指定，回收时加入）：堆空间不足时被回收
	弱引用（引用队列，构造时指定，回收时加入）：发现就会被回收
	虚引用：必须和引用队列一起使用，跟踪垃圾回收过程
13、垃圾回收时的停顿现象（stop the world）
	Visual GC工具